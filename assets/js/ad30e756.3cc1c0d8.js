"use strict";(self.webpackChunkjs_and_ts_in_depth_elective=self.webpackChunkjs_and_ts_in_depth_elective||[]).push([[1624],{8221:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"typescript_fundamentals/intersection_types","title":"Intersection types (&)","description":"Un intersection type combina varios tipos en uno m\xe1s estricto que debe cumplir todos los contratos a la vez.","source":"@site/docs/02_typescript_fundamentals/07_intersection_types.md","sourceDirName":"02_typescript_fundamentals","slug":"/typescript_fundamentals/intersection_types","permalink":"/JS_and_TS_In-depth_Elective/docs/typescript_fundamentals/intersection_types","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_typescript_fundamentals/07_intersection_types.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Union types (|)","permalink":"/JS_and_TS_In-depth_Elective/docs/typescript_fundamentals/union_types"},"next":{"title":"Tipos literales y enums","permalink":"/JS_and_TS_In-depth_Elective/docs/typescript_fundamentals/literal_types_and_enums"}}');var t=s(4848),r=s(8453);const a={sidebar_position:7},o="Intersection types (&)",c={},d=[{value:"Ejemplos fundamentales",id:"ejemplos-fundamentales",level:2},{value:"Matices y &quot;gotchas&quot;",id:"matices-y-gotchas",level:2},{value:"Patrones profesionales",id:"patrones-profesionales",level:2},{value:"Composici\xf3n por intersecci\xf3n",id:"composici\xf3n-por-intersecci\xf3n",level:2},{value:"Referencias",id:"referencias",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"intersection-types-",children:"Intersection types (&)"})}),"\n",(0,t.jsxs)(n.p,{children:["Un ",(0,t.jsx)(n.strong,{children:"intersection type"})," combina varios tipos en ",(0,t.jsx)(n.strong,{children:"uno m\xe1s estricto"})," que ",(0,t.jsx)(n.strong,{children:"debe cumplir"})," todos los contratos a la vez."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"A & B"})," significa ",(0,t.jsx)(n.code,{children:"A"})," y ",(0,t.jsx)(n.code,{children:"B"})," simult\xe1neamente."]}),"\n",(0,t.jsxs)(n.li,{children:["\xdatil para ",(0,t.jsx)(n.strong,{children:"componer capacidades"})," (mixins, traits), ",(0,t.jsx)(n.strong,{children:"enriquecer contratos"})," en fronteras (request + contexto), ",(0,t.jsx)(n.strong,{children:"marcar/brandear"})," tipos nominales, y ",(0,t.jsx)(n.strong,{children:"refinar"})," datos validados."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"success",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Regla pr\xe1ctica:"})," usa ",(0,t.jsx)(n.code,{children:"&"})," para a\xf1adir responsabilidades a un tipo sin herencia (composici\xf3n > herencia)."]})}),"\n",(0,t.jsx)(n.h2,{id:"ejemplos-fundamentales",children:"Ejemplos fundamentales"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Composici\xf3n de capacidades (traits):"})," En lugar de crear una gran interfaz con michas responsabilidades, se definen ",(0,t.jsx)(n.strong,{children:"tipos peque\xf1os y especializados"})," que representan capacidades individuales. Luego, se ",(0,t.jsx)(n.strong,{children:"combinan"})," para formar entidades m\xe1s completas. Esto promueve la modularidad y la reutilizaci\xf3n."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'type Identifiable = { id: string };\ntype Timestamped = { createdAt: Date; updatedAt: Date };\n\ntype AuditedEntity = Identifiable & Timestamped;\n\nconst order: AuditedEntity = {\n  id: "o_1",\n  createdAt: new Date(),\n  updatedAt: new Date(),\n};\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Extender contratos en fronteras (HTTP/infra):"})," En Clean Architecture, las fronteras (como controladores HTTP, adaptadores CLI, etc) reciben datos del mundo exterior. Para procesarlos correctamente, muchas veces necesitamos ",(0,t.jsx)(n.strong,{children:"enriquecer esos datos"})," con contexto adicional (como autenticaci\xf3n, trazabilidad, etc)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"type HttpRequest = { url: string; headers: Record<string, string> };\ntype AuthContext = { userId: string; roles: string[] };\n\ntype AuthedRequest = HttpRequest & AuthContext;\n\nfunction handle(req: AuthedRequest) {\n  // tiene url, headers, userId, roles\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Branding nominal (evitar mezclar strings):"})," TypeScript usa un sistema de tipos estructural, lo que significa que dos tipos son compatibles si tienen la misma forma. Esto puede ser peligroso cuando usamos ",(0,t.jsx)(n.code,{children:"string"})," para representar cosas distintas como ",(0,t.jsx)(n.code,{children:"UserId"}),", ",(0,t.jsx)(n.code,{children:"OrderId"}),", ",(0,t.jsx)(n.code,{children:"SessionToken"}),", etc. Aunque todas son cadenas, ",(0,t.jsx)(n.strong,{children:"sem\xe1nticamente no deber\xedan mezclarse"}),". El branding nominal introduce una marca oculta en el tipo para que el compilador los trate como ",(0,t.jsx)(n.strong,{children:"tipos distintos"}),", aunque tengan la misma estructura."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'type Brand<T, K extends string> = T & { readonly __brand: K };\n\ntype UserId = Brand<string, "UserId">;\ntype OrderId = Brand<string, "OrderId">;\n\nconst uid = "u_1" as UserId;\n// const bad: UserId = "o_1" as OrderId; // \u274c Brands Incompatibles\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Refinamiento tras validaci\xf3n (type guards):"})," Cuando recibimos datos de fuentes externas (como HTTP, CLI, archivos, etc), el tipo suele ser ",(0,t.jsx)(n.code,{children:"unknown"})," o muy gen\xe9rico. Para trabajar con seguridad, necesitamos ",(0,t.jsx)(n.strong,{children:"validar"})," que esos datos cumplen ciertas estructuras, y luego ",(0,t.jsx)(n.strong,{children:"refinar su tipo"})," para que el compilador nos permita operar con ellos sin perder seguridad. Los type guards son funciones que hacen exactamente eso: verifican una condici\xf3n y, si se cumple, ",(0,t.jsx)(n.strong,{children:"informan al compilador"})," que el valor tiene un tipo m\xe1s espec\xedfico."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'type WithId = { id: string };\ntype WithName = { name: string };\n\nfunction hasId(x: unknown): x is WithId {\n  return !!x && typeof (x as any).id === "string";\n}\nfunction hasName(x: unknown): x is WithName {\n  return !!x && typeof (x as any).name === "string";\n}\n\nfunction toUser(x: unknown): WithId & WithName {\n  if (hasId(x) && hasName(x)) return x;      // Ahora se tipa como intersecci\xf3n\n  throw new Error("Invalid user");\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:'Funciones: intersecci\xf3n como "sobrecarga" compatible:'})," Cuando usamos ",(0,t.jsx)(n.code,{children:"FnA & FnB"}),", estamos diciendo que la funci\xf3n debe ",(0,t.jsx)(n.strong,{children:"cumplir ambas firmas"}),": debe aceptar un ",(0,t.jsx)(n.code,{children:"number"})," como entrada y un string como entrada, y en ambos casos devolver un string. Esto no es lo mismo que una uni\xf3n (",(0,t.jsx)(n.code,{children:"FnA | FnB"}),"), que implicar\xeda que la funci\xf3n cumple ",(0,t.jsx)(n.strong,{children:"una u otra"})," firma. La intersecci\xf3n exige que la funci\xf3n sea ",(0,t.jsx)(n.strong,{children:"compatible con ambas"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"type FnA = (x: number) => string;\ntype FnB = (x: string) => string;\n\ntype Fn = FnA & FnB; // debe aceptar number AND string\n\nconst fn: Fn = (x: number | string) => String(x).toUpperCase();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Una variable de tipo ",(0,t.jsx)(n.code,{children:"FnA & FnB"})," debe poder manejar ambas firmas."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"matices-y-gotchas",children:'Matices y "gotchas"'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Conflictos de propiedades:"})}),"\n",(0,t.jsxs)(n.p,{children:["Si el mismo campo tiene ",(0,t.jsx)(n.strong,{children:"tipos incompatibles"}),", la intersecci\xf3n colapsa (efectivamente ",(0,t.jsx)(n.strong,{children:"inusable"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"type A = { x: string };\ntype B = { x: number };\ntype C = A & B; // { x: never } \u2192 imposible de instanciar en la pr\xe1ctica\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Intersecci\xf3n con uniones y precedencia:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"&"})," tiene mayor precedencia que ",(0,t.jsx)(n.code,{children:"|"}),": ",(0,t.jsx)(n.code,{children:"A | B & C"})," es igual a ",(0,t.jsx)(n.code,{children:"A | (B & C)"})]}),"\n",(0,t.jsxs)(n.li,{children:["Distribuci\xf3n: ",(0,t.jsx)(n.code,{children:"(A | B) & C"})," puede ser visto como ",(0,t.jsx)(n.code,{children:"(A & C) | (B & C)"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'type Base = { id: string };\ntype Admin = { role: "admin"; perms: string[] };\ntype User  = { role: "user" };\n\ntype X = Base | Admin & Base; // Es igual a Base | (Admin & Base) pero es diferente a (Base | Admin) & Base\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Opci\xf3n vs suma de capacidades:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Opcional: ",(0,t.jsx)(n.code,{children:"{a?: string}"})," (mismo chape con campo opcional)."]}),"\n",(0,t.jsxs)(n.li,{children:["Intersecci\xf3n: ",(0,t.jsx)(n.code,{children:"TypeA & TypeB"})," (uni\xf3n de miembros, m\xe1s estricto)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"patrones-profesionales",children:"Patrones profesionales"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Mixins con funciones (composici\xf3n a partir de objetos):"})," Un mixin es una t\xe9cnica de composici\xf3n que permite extender objetos con nuevas capacidades sin necesidad de herencia. En lugar de crear jerarqu\xedas de clases, se combinan comportamientos mediante funciones que agregan propiedades o m\xe9todos a un objeto existente."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'type WithSoftDelete = { deletedAt?: Date; delete(): void };\ntype WithTenant = { tenantId: string };\n\nfunction makeSoftDeletable<T extends object>(o: T): T & WithSoftDelete {\n  return Object.assign(o, {\n    delete() { (o as any).deletedAt = new Date(); }\n  });\n}\n\nconst entity = makeSoftDeletable({ id: "1", tenantId: "t1" }) as\n  { id: string; tenantId: string } & WithSoftDelete;\n\nentity.delete();\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Composici\xf3n de DTOs con utilitarios:"})," Un DTO (Data Transfer Object) es una estructura que representa datos que se env\xedan o reciben entre capas de una aplicaci\xf3n. Su prop\xf3sito es transportar informaci\xf3n de forma clara, tipada y controlada, sin incluir l\xf3gica de negocio."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"type BaseDTO = Readonly<{ id: string; createdAt: string }>;\ntype Updatable = Partial<{ name: string; email: string }>;\n\ntype UpdateUserDTO = BaseDTO & Updatable;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Suma requisitos estables (",(0,t.jsx)(n.code,{children:"BaseDTO"}),") con campos editables (",(0,t.jsx)(n.code,{children:"Partial<>"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:'"Result" enriquecido con metadatos:'}),' El patr\xf3n "Result" es una forma funcional de representar el resultado de una operaci\xf3n que puede:']}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Tener \xe9xito (",(0,t.jsx)(n.code,{children:"OK<T>"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Fallar (",(0,t.jsx)(n.code,{children:"Fail<E>"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Este enfoque evita el uso de excepciones y promueve un manejo expl\xedcito de errores."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'type Ok<T>   = { kind: "ok"; value: T };\ntype Fail<E> = { kind: "error"; error: E };\n\ntype WithMeta = { requestId: string; ts: number };\n\ntype RichResult<T, E = Error> = (Ok<T> | Fail<E>) & WithMeta;\n\nconst r: RichResult<number> = {\n  kind: "ok", value: 42, requestId: "req-1", ts: Date.now()\n};\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Endurecer opcionales mediante ",(0,t.jsx)(n.code,{children:"&"}),":"]})," En TypeScript, una propiedad marcada como opcional (",(0,t.jsx)(n.code,{children:"email?: string"}),") puede estar presente o no. Sin embargo, en ciertos contextos, (por ejemplo, validaci\xf3n, persistencia o actualizaci\xf3n), podr\xedas necesitar garantizar que esa propiedad est\xe1 presente. La t\xe9cnica consiste en componer el tipo original con otro que exige la propiedad, convirti\xe9ndola en obligatoria."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"type UserBase = { id: string; email?: string };\ntype RequireEmail = { email: string };\n\ntype UserWithEmail = UserBase & RequireEmail; // email pasa a ser requerido\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reutilizar invariantes en casos de uso (Clean Architecture):"})," En el contexto de Clean Architecture, los invariantes son propiedades o reglas que se mantienen constantes en todas las entidades del dominio. Son fundamentales para garantizar consistencia, trazabilidad y control de versiones en los modelos de negocio."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:'// domain/contracts\nexport type Identified = { id: string };\nexport type Versioned  = { version: number };\n\nexport type AggregateRoot = Identified & Versioned;\n\n// application/usecases\nexport interface Order extends AggregateRoot {\n  total: number;\n  status: "PENDING" | "PAID";\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"composici\xf3n-por-intersecci\xf3n",children:"Composici\xf3n por intersecci\xf3n"}),"\n",(0,t.jsx)(n.mermaid,{value:"classDiagram\n  direction BT\n  class Identifiable { \n    <<interface>> \n    +id: string \n  }\n  class Timestamped {\n    <<interface>>\n    +createdAt: Date\n    +updatedAt: Date \n  }\n  class AuditedEntity {\n    +id: string\n    +createdAt: Date\n    +updatedAt: Date\n  }\n\n  AuditedEntity --|> Identifiable : implements\n  AuditedEntity --|> Timestamped : implements"}),"\n",(0,t.jsxs)(n.p,{children:["En concepto, ",(0,t.jsx)(n.code,{children:"AuditedEntity"})," cumple ambos contratos (",(0,t.jsx)(n.code,{children:"Identifiable"})," y ",(0,t.jsx)(n.code,{children:"Timestamped"}),")"]}),"\n",(0,t.jsx)(n.h2,{id:"referencias",children:"Referencias"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Microsoft. (s.f.). ",(0,t.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/",children:"TypeScript Handbook: Unions and Intersections"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Vanderkam, D. (2019). Effective TypeScript: 62 Specific Ways to Improve Your TypeScript. O\u2019Reilly Media."}),"\n",(0,t.jsx)(n.li,{children:"Flanagan, D. (2020). JavaScript: The Definitive Guide (7.\xaa ed.). O\u2019Reilly Media."}),"\n",(0,t.jsx)(n.li,{children:"Zakas, N. C. (2012). Maintainable JavaScript: Writing Readable Code. O\u2019Reilly Media."}),"\n",(0,t.jsxs)(n.li,{children:["Google. (s.f.). ",(0,t.jsx)(n.a,{href:"https://google.github.io/styleguide/jsguide.html",children:"JavaScript Style Guide"}),"."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(6540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);