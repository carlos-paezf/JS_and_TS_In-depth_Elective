"use strict";(self.webpackChunkjs_and_ts_in_depth_elective=self.webpackChunkjs_and_ts_in_depth_elective||[]).push([[7567],{4093:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"typescript_fundamentals/type_inference_vs_explicit_annotation","title":"Inferencia de tipos vs anotaci\xf3n expl\xedcita","description":"- Inferencia: TypeScript deduce el tipo a partir del valor o del contexto. Es potente, concisa y suele bastar para variables locales y expresiones internas.","source":"@site/docs/02_typescript_fundamentals/02_type_inference_vs_explicit_annotation.md","sourceDirName":"02_typescript_fundamentals","slug":"/typescript_fundamentals/type_inference_vs_explicit_annotation","permalink":"/JS_and_TS_In-depth_Elective/docs/typescript_fundamentals/type_inference_vs_explicit_annotation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_typescript_fundamentals/02_type_inference_vs_explicit_annotation.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Tipos primitivos y estructuras","permalink":"/JS_and_TS_In-depth_Elective/docs/typescript_fundamentals/primitive_types_and_data_structures"},"next":{"title":"Tipado en funciones y par\xe1metros opcionales","permalink":"/JS_and_TS_In-depth_Elective/docs/typescript_fundamentals/function_typing_and_optional_parameters"}}');var s=r(4848),a=r(8453);const t={sidebar_position:2},o="Inferencia de tipos vs anotaci\xf3n expl\xedcita",c={},l=[{value:"Inferencia en variables y expresiones",id:"inferencia-en-variables-y-expresiones",level:2},{value:"Widening vs literal types",id:"widening-vs-literal-types",level:2},{value:"Inferencia contextual (par\xe1metros y lambdas)",id:"inferencia-contextual-par\xe1metros-y-lambdas",level:2},{value:"Inferencia en funciones (retorno) vs anotaci\xf3n expl\xedcita",id:"inferencia-en-funciones-retorno-vs-anotaci\xf3n-expl\xedcita",level:2},{value:"Inferencia en gen\xe9ricos (con l\xedmites)",id:"inferencia-en-gen\xe9ricos-con-l\xedmites",level:2},{value:"Objetos y &quot;shape&quot; inferidos vs contratos expl\xedcitos",id:"objetos-y-shape-inferidos-vs-contratos-expl\xedcitos",level:2},{value:"Cu\xe1ndo anotar expl\xedcitamente",id:"cu\xe1ndo-anotar-expl\xedcitamente",level:2},{value:"Cu\xe1ndo permitir inferencia",id:"cu\xe1ndo-permitir-inferencia",level:2},{value:"Ejemplo integral (Clean Architecture)",id:"ejemplo-integral-clean-architecture",level:2},{value:"Errores comunes y c\xf3mo evitarlos",id:"errores-comunes-y-c\xf3mo-evitarlos",level:2},{value:"Patr\xf3n &quot;type guards&quot; con <code>unknown</code>",id:"patr\xf3n-type-guards-con-unknown",level:2},{value:"Decidir entre inferencia y anotaci\xf3n",id:"decidir-entre-inferencia-y-anotaci\xf3n",level:2},{value:"Edge vs Inside",id:"edge-vs-inside",level:2},{value:"Buenas pr\xe1cticas",id:"buenas-pr\xe1cticas",level:2},{value:"Referencias",id:"referencias",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"inferencia-de-tipos-vs-anotaci\xf3n-expl\xedcita",children:"Inferencia de tipos vs anotaci\xf3n expl\xedcita"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inferencia:"})," TypeScript deduce el tipo a partir del valor o del contexto. Es potente, concisa y suele bastar para variables locales y expresiones internas."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Anotaci\xf3n expl\xedcita:"})," el programador declara el tipo. Es esencial en fronteras p\xfablicas (APIs, m\xf3dulos, contratos) y para controlar el dise\xf1o cuando la inferencia no refleja la intenci\xf3n."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Regla pr\xe1ctica:"})," Infiera dentro de la implementaci\xf3n, anote en las fronteras. ",(0,s.jsx)(n.em,{children:"(\u201cInfer inside, annotate at the edges.\u201d)"})]})}),"\n",(0,s.jsx)(n.h2,{id:"inferencia-en-variables-y-expresiones",children:"Inferencia en variables y expresiones"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Local variables \u2013 concise & safe\nconst port = 8080;          // inferred: number\nlet active = true;          // inferred: boolean\nconst message = 'OK';       // inferred: \"OK\" (literal) \u2192 widened to string if needed\n\n// Contextual inference inside expressions\nconst users = ['Ana', 'Luis']; // inferred: string[]\nconst coords = [10, 20] as const; // inferred: readonly [10, 20]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"widening-vs-literal-types",children:"Widening vs literal types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"const msg = 'READY'"}),": tipo literal 'READY'"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"let msg = 'READY'"}),": se ensancha (widen) a string"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip:"})," Usa ",(0,s.jsx)(n.code,{children:"as const"})," para congelar literales cuando quieras preservar su tipo exacto en configuraciones/constantes."]}),"\n",(0,s.jsx)(n.h2,{id:"inferencia-contextual-par\xe1metros-y-lambdas",children:"Inferencia contextual (par\xe1metros y lambdas)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"const names = ['David', 'Tommy'];\nnames.forEach(n => {\n  // `n` is inferred as string by context\n  console.log(n.toUpperCase());\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Aqu\xed el compilador ",(0,s.jsx)(n.strong,{children:"deduce"})," ",(0,s.jsx)(n.code,{children:"n: string"})," por el tipo de ",(0,s.jsx)(n.code,{children:"names"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"inferencia-en-funciones-retorno-vs-anotaci\xf3n-expl\xedcita",children:"Inferencia en funciones (retorno) vs anotaci\xf3n expl\xedcita"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"// 1) Internal helper \u2013 inference is fine\nfunction double(n: number) {\n  return n * 2; // inferred return: number\n}\n\n// 2) Public API \u2013 explicit return improves contracts\nexport function toSlug(input: string): string {\n  return input.trim().toLowerCase().replace(/\\s+/g, '-');\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Para funciones exportadas y m\xe9todos p\xfablicos:"})," anota el tipo de retorno para fijar el contrato y evitar que refactors cambien silenciosamente la API."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Para utilidades internas:"})," la inferencia del retorno suele ser suficiente."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"inferencia-en-gen\xe9ricos-con-l\xedmites",children:"Inferencia en gen\xe9ricos (con l\xedmites)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"/**\n * Map over a list with a transformer.\n * @param items Input list\n * @param fn Transformer\n */\nexport function mapOf<T, U>(items: T[], fn: (x: T) => U): U[] {\n  return items.map(fn);\n}\n\n// Call-site infers T = number, U = string\nconst lengths = mapOf([10, 20, 30], n => `#${n}`); // string[]\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["TypeScript infiera ",(0,s.jsx)(n.code,{children:"T"})," y ",(0,s.jsx)(n.code,{children:"U"})," desde los argumentos."]}),"\n",(0,s.jsxs)(n.li,{children:["Si el uso es ambiguo, anota el gen\xe9rico: ",(0,s.jsx)(n.code,{children:"mapOf<number, string>(...)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"objetos-y-shape-inferidos-vs-contratos-expl\xedcitos",children:'Objetos y "shape" inferidos vs contratos expl\xedcitos'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"// Inference for internal data\nconst config = {\n  retries: 3,\n  strategy: 'exponential',\n}; // inferred: { retries: number; strategy: string }\n\n// Public contract \u2192 prefer interface/type\nexport interface RetryConfig {\n  retries: number;\n  strategy: 'constant' | 'exponential';\n}\n\nexport function withRetry(cfg: RetryConfig) { /* ... */ }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Cuando el objeto cruza una ",(0,s.jsx)(n.strong,{children:"frontera"})," (entrada de funci\xf3n p\xfablica, DTO, respuesta de capa de infraestructura), usa ",(0,s.jsx)(n.strong,{children:"tipos expl\xedcitos"})," (interfaces/aliases) para fijar el contrato."]}),"\n",(0,s.jsx)(n.h2,{id:"cu\xe1ndo-anotar-expl\xedcitamente",children:"Cu\xe1ndo anotar expl\xedcitamente"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fronteras p\xfablicas:"})," firmas de funciones/m\xe9todos exportados, controllers, use-cases, adapters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tipos de retorno"})," en APIs p\xfablicas."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tipos gen\xe9ricos"})," cuando la inferencia es ambigua."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Uniones/Intersecciones"})," complejas para documentar intenci\xf3n."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unknown"})," sobre ",(0,s.jsx)(n.code,{children:"any"})," al recibir datos externos (validar antes de usar)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"cu\xe1ndo-permitir-inferencia",children:"Cu\xe1ndo permitir inferencia"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Variables locales, resultados intermedios."}),"\n",(0,s.jsx)(n.li,{children:"Callbacks con contexto claro (map, filter, reduce)."}),"\n",(0,s.jsx)(n.li,{children:"Implementaciones privadas dentro de un m\xf3dulo/capa."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ejemplo-integral-clean-architecture",children:"Ejemplo integral (Clean Architecture)"}),"\n",(0,s.jsx)(n.p,{children:"El objetivo del ejemplo es mostrar expl\xedcito en edges e inferencia dentro de la implementaci\xf3n."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="domain/entities/order.ts" showLineNumbers',children:"export interface Order {\n  id: string;\n  total: number;\n  status: 'PENDING' | 'PAID' | 'CANCELLED';\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="domain/ports/order.repository.ts" showLineNumbers',children:"export interface OrderRepository {\n  findById(id: string): Promise<Order | null>;\n  save(order: Order): Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="application/usecases/pay_order.ts" showLineNumbers',children:"export class PayOrder {\n  constructor(private readonly repo: OrderRepository) {}\n\n  /**\n   * Public API of the use case \u2014 explicit types at the edge.\n   */\n  async execute(orderId: string): Promise<Order> {\n    const order = await this.repo.findById(orderId);\n    if (!order) throw new Error('Order not found');\n\n    // Internal variables \u2014 inference is fine\n    const updated = { ...order, status: 'PAID' as const };\n\n    await this.repo.save(updated);\n    return updated; // return type is explicitly Promise<Order>\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="infrastructure/repositories/in_memory_order.repository.ts" showLineNumbers',children:"import { Order, OrderRepository } from 'domain/...';\n\nexport class InMemoryOrderRepo implements OrderRepository {\n  private store = new Map<string, Order>(); // inferred Map<string, Order>\n\n  findById(id: string): Promise<Order | null> {\n    return Promise.resolve(this.store.get(id) ?? null);\n  }\n\n  save(order: Order): Promise<void> {\n    this.store.set(order.id, order);\n    return Promise.resolve();\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dominio/puertos:"})," contratos expl\xedcitos."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Casos de uso:"})," firmas p\xfablicas expl\xedcitas; variables internas inferidas."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Infraestructura:"})," implementaciones con inferencias locales."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"errores-comunes-y-c\xf3mo-evitarlos",children:"Errores comunes y c\xf3mo evitarlos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"any"})," impl\xedcito (por ",(0,s.jsx)(n.code,{children:"noImplicitAny: false"}),"): Activa ",(0,s.jsx)(n.code,{children:'"noImplicitAny": true'})," en ",(0,s.jsx)(n.code,{children:"tsconfig.json"}),". Si necesitas \u201ccaja negra\u201d, usa ",(0,s.jsx)(n.code,{children:"unknown"})," y valida."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Arrays vac\xedo sin tipo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"let xs = [];              // any[]  (riesgoso)\nconst ys: number[] = [];  // expl\xedcito\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Retornos accidentales"})," por refactor: Sin tipo expl\xedcito, un cambio interno puede alterar el tipo de retorno. Anota retornos en funciones exportadas."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Uniones demasiado anchas por inferencia:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"const mixed = [1, 'a'];    // (string | number)[]\nconst strict = [1, 2] as const; // readonly [1, 2]\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Perder literal types con ",(0,s.jsx)(n.code,{children:"let"}),": Usa ",(0,s.jsx)(n.code,{children:"const"})," o ",(0,s.jsx)(n.code,{children:"as const"})," cuando quieras preservar literales."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"patr\xf3n-type-guards-con-unknown",children:['Patr\xf3n "type guards" con ',(0,s.jsx)(n.code,{children:"unknown"})]}),"\n",(0,s.jsxs)(n.p,{children:["Al patr\xf3n ",(0,s.jsx)(n.code,{children:"type guards"}),' se le conoce c\xf3mo "type guards" (guardias de tipo). Es una t\xe9cnica para comprobar si un valor de tipo ',(0,s.jsx)(n.code,{children:"unknown"})," puede ser de un tipo espec\xedfico. Esto se logra mediante una funci\xf3n que devuelve un valor de tipo booleano que indica si el valor de entrada es de un tipo espec\xedfico. Si el valor es de ese tipo, la funci\xf3n devuelve ",(0,s.jsx)(n.code,{children:"true"}),", de lo contrario devuelve ",(0,s.jsx)(n.code,{children:"false"}),". Si el valor es de ese tipo, puedes usar el valor de entrada como si fuera de ese tipo. Por ejemplo:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"type User = { id: string; name: string };\n\nfunction isUser(x: unknown): x is User {\n  return !!x && typeof x === 'object'\n    && typeof (x as any).id === 'string'\n    && typeof (x as any).name === 'string';\n}\n\nexport function parseUser(input: unknown): User {\n  if (!isUser(input)) throw new Error('Invalid User');\n  return input; // now input is User\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Recibir ",(0,s.jsx)(n.code,{children:"unknown"})," obliga a ",(0,s.jsx)(n.strong,{children:"verificar"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Tras el ",(0,s.jsx)(n.em,{children:"type guard"}),", el compilador ",(0,s.jsx)(n.strong,{children:"refina"})," el tipo (narrowing)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decidir-entre-inferencia-y-anotaci\xf3n",children:"Decidir entre inferencia y anotaci\xf3n"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TD\n  A["\xbfEl s\xedmbolo es parte de una API p\xfablica?"] --\x3e|S\xed| B["Anota tipos expl\xedcitos (params y return)"]\n  A --\x3e|No| C["\xbfLa intenci\xf3n queda clara con inferencia?"]\n  C --\x3e|S\xed| D["Usa inferencia para variables locales"]\n  C --\x3e|No| E["Anota para documentar intenci\xf3n"]\n  B --\x3e F["\xbfGen\xe9ricos ambiguos? Anota/Restringe"]\n  D --\x3e G["\xbfLiteral debe preservarse? Usa as const"]\n  E --\x3e H["Prefiere unknown sobre any en datos externos"]'}),"\n",(0,s.jsx)(n.h2,{id:"edge-vs-inside",children:"Edge vs Inside"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    autonumber\n    participant Dev\n    participant PublicAPI as Public API (explicit)\n    participant Impl as Implementation (inferred)\n\n    Dev->>PublicAPI: Define signature (params & return types)\n    PublicAPI--\x3e>Impl: Call internal helpers\n    Impl--\x3e>Impl: Local variables (inference)\n    Impl--\x3e>PublicAPI: Return matches explicit contract"}),"\n",(0,s.jsx)(n.h2,{id:"buenas-pr\xe1cticas",children:"Buenas pr\xe1cticas"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Code:"})," menos ruido donde la inferencia es clara; contratos expl\xedcitos donde importa la comunicaci\xf3n."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SRP (S):"})," los tipos documentan responsabilidad; \u201cuna funci\xf3n, un prop\xf3sito\u201d."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OCP (O):"})," APIs tipadas son extensibles y seguras ante cambios internos."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DIP (D):"})," programa contra interfaces expl\xedcitas, no implementaciones; la inferencia queda para la \u201ccocina interna\u201d."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Architecture:"})," dominio y puertos con tipos expl\xedcitos; infraestructura y aplicaci\xf3n aprovechan inferencia local."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"referencias",children:"Referencias"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Microsoft. (s.f.). ",(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/",children:"TypeScript Handbook: Basic & Variable Declarations, Functions, Generics, Type Inference"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Bierman, G., Abadi, M., & Torgersen, M. (2014). Understanding TypeScript. Microsoft Research."}),"\n",(0,s.jsx)(n.li,{children:"Flanagan, D. (2020). JavaScript: The Definitive Guide (7.\xaa ed.). O\u2019Reilly Media."}),"\n",(0,s.jsx)(n.li,{children:"Zakas, N. C. (2012). Maintainable JavaScript: Writing Readable Code. O\u2019Reilly Media."}),"\n",(0,s.jsxs)(n.li,{children:["Google. (s.f.). ",(0,s.jsx)(n.a,{href:"https://google.github.io/styleguide/jsguide.html",children:"JavaScript Style Guide"}),"."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var i=r(6540);const s={},a=i.createContext(s);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);